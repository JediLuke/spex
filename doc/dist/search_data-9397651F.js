searchData={"items":[{"type":"module","title":"Spex","doc":"Executable specifications for AI-driven development.\n\nSpex provides a framework for writing executable specifications that serve as\nboth tests and living documentation, optimized for AI-driven development workflows.","ref":"Spex.html"},{"type":"module","title":"Technical Architecture - Spex","doc":"Spex is built on top of ExUnit but provides a controlled execution environment\nspecifically designed for AI-driven testing. Here's how it works:","ref":"Spex.html#module-technical-architecture"},{"type":"module","title":"Core Architecture - Spex","doc":"1. **ExUnit Foundation**: Spex uses ExUnit.Case under the hood for all test execution\n2. **Custom DSL**: Adds spex/scenario/given_/when_/then_ macros via Spex.DSL\n3. **Controlled Execution**: Only runs via `mix spex` command, never through `mix test`\n4. **Framework Helpers**: Provides Spex.Helpers for common patterns like app startup","ref":"Spex.html#module-core-architecture"},{"type":"module","title":"Execution Flow - Spex","doc":"```\nmix spex → Mix.Tasks.Spex → ExUnit.start() → Load spex files → ExUnit.run()\n```","ref":"Spex.html#module-execution-flow"},{"type":"module","title":"Why Not Standard ExUnit? - Spex","doc":"- **Compilation Control**: `mix spex` ensures proper compilation for complex dependency trees\n- **Application Lifecycle**: Better control over starting/stopping GUI applications\n- **AI-Optimized**: Manual mode, step-by-step execution, semantic helpers\n- **Cleaner Interface**: No confusion about tags, includes, or execution methods","ref":"Spex.html#module-why-not-standard-exunit"},{"type":"module","title":"File Structure - Spex","doc":"```\ntest/spex/\n  hello_world_spex.exs     # Basic connectivity test\n  user_workflow_spex.exs   # Complex user interactions\n  screenshots/             # Generated screenshots\n```","ref":"Spex.html#module-file-structure"},{"type":"module","title":"Under the Hood - Spex","doc":"When you write:\n```elixir\nuse Spex\n```\n\nYou get:\n```elixir\nuse ExUnit.Case, async: false  # Standard ExUnit test case\nimport Spex.DSL               # spex/scenario/given_/when_/then_\nrequire Logger                # Logging support\n```\n\nThis means you have access to all standard ExUnit features:\n- `assert`, `refute`, `assert_raise`, etc.\n- `setup_all`, `setup` callbacks\n- `on_exit` for cleanup\n- Pattern matching in tests","ref":"Spex.html#module-under-the-hood"},{"type":"module","title":"Spex vs ExUnit - Spex","doc":"| Feature | Spex | ExUnit |\n|---------|------|--------|\n| Execution | `mix spex` only | `mix test` |\n| File Pattern | `*_spex.exs` | `*_test.exs` |\n| DSL | Given/When/Then | test/describe |\n| Target Use | AI-driven GUI testing | General testing |\n| Manual Mode | ✅ Built-in | ❌ Not available |\n| App Lifecycle | ✅ Helpers provided | Manual setup |","ref":"Spex.html#module-spex-vs-exunit"},{"type":"module","title":"Integration with Scenic Applications - Spex","doc":"Spex provides special helpers for Scenic GUI applications:\n- `Spex.Helpers.start_scenic_app/2` - Start app with MCP server\n- `Spex.Helpers.can_connect_to_scenic_mcp?/1` - Test connectivity\n- `Spex.Helpers.application_running?/1` - Check app status\n\nThis makes AI-driven GUI testing much simpler and more reliable.","ref":"Spex.html#module-integration-with-scenic-applications"},{"type":"module","title":"Basic Example - Spex","doc":"defmodule MyApp.UserSpex do\n      use Spex\n\n      spex \"user registration works\" do\n        scenario \"successful registration\" do\n          given_ \"valid user data\" do\n            user_data = %{email: \"test@example.com\", password: \"secure123\"}\n            assert valid_user_data?(user_data)\n          end\n\n          when_ \"user registers\" do\n            {:ok, user} = MyApp.register_user(user_data)\n            assert user.email == \"test@example.com\"\n          end\n\n          then_ \"user can login\" do\n            assert {:ok, _session} = MyApp.authenticate(user_data.email, user_data.password)\n          end\n        end\n      end\n    end","ref":"Spex.html#module-basic-example"},{"type":"module","title":"GUI Application Testing - Spex","doc":"For GUI applications, use Spex.Helpers for easy setup:\n\n    defmodule MyApp.GUISpex do\n      use Spex\n\n      setup_all do\n        # Start GUI application with MCP server\n        Spex.Helpers.start_scenic_app(:my_gui_app)\n      end\n\n      setup do\n        # Reset state before each spex\n        {:ok, %{timestamp: DateTime.utc_now()}}\n      end\n\n      spex \"GUI interaction works\", context do\n        scenario \"application connectivity\", context do\n          given_ \"application is running\", context do\n            assert Spex.Helpers.application_running?(:my_gui_app)\n            context\n          end\n\n          then_ \"we can connect to MCP server\", context do\n            assert Spex.Helpers.can_connect_to_scenic_mcp?(context.port)\n            context\n          end\n        end\n      end\n    end","ref":"Spex.html#module-gui-application-testing"},{"type":"module","title":"Running Spex - Spex","doc":"Spex files can only be executed via the `mix spex` command:\n\n    # Run all spex files\n    mix spex\n\n    # Run specific spex file  \n    mix spex test/spex/my_app_spex.exs\n\n    # Run in manual mode (step-by-step)\n    mix spex --manual\n\n**Important**: Spex files cannot be run via `mix test`. This ensures proper\ncompilation and application lifecycle management for AI-driven testing.","ref":"Spex.html#module-running-spex"},{"type":"module","title":"Spex.DSL","doc":"Domain-specific language for writing executable specifications.\n\nProvides macros for structuring specifications in a readable, executable format\nfollowing the Given-When-Then pattern.","ref":"Spex.DSL.html"},{"type":"macro","title":"Spex.DSL.and_/2","doc":"Defines additional context or cleanup.","ref":"Spex.DSL.html#and_/2"},{"type":"macro","title":"Spex.DSL.and_/3","doc":"","ref":"Spex.DSL.html#and_/3"},{"type":"macro","title":"Spex.DSL.given_/2","doc":"Defines the preconditions for a test scenario.","ref":"Spex.DSL.html#given_/2"},{"type":"macro","title":"Examples - Spex.DSL.given_/2","doc":"# Without context\n    given_ \"some setup\" do\n      # setup code\n    end\n    \n    # With context (ExUnit style)\n    given_ \"some setup\", context do\n      data = setup()\n      context = Map.put(context, :data, data)\n    end","ref":"Spex.DSL.html#given_/2-examples"},{"type":"macro","title":"Spex.DSL.given_/3","doc":"","ref":"Spex.DSL.html#given_/3"},{"type":"macro","title":"Spex.DSL.scenario/2","doc":"Defines a scenario within a specification.\n\nScenarios group related Given-When-Then steps together.","ref":"Spex.DSL.html#scenario/2"},{"type":"macro","title":"Spex.DSL.scenario/3","doc":"Defines a scenario with context support.\n\nContext is passed between steps similar to ExUnit's approach.","ref":"Spex.DSL.html#scenario/3"},{"type":"macro","title":"Example - Spex.DSL.scenario/3","doc":"scenario \"user workflow\", context do\n      given_ \"a user\", context do\n        user = create_user()\n        context = Map.put(context, :user, user)\n      end\n      \n      when_ \"they login\", context do\n        session = login(context.user)\n        context = Map.put(context, :session, session)\n      end\n      \n      then_ \"they see dashboard\", context do\n        assert context.session.valid?\n      end\n    end","ref":"Spex.DSL.html#scenario/3-example"},{"type":"macro","title":"Spex.DSL.spex/3","doc":"Defines a specification.","ref":"Spex.DSL.html#spex/3"},{"type":"macro","title":"Example - Spex.DSL.spex/3","doc":"spex \"user can login\", tags: [:authentication] do\n      scenario \"with valid credentials\" do\n        # test implementation\n      end\n    end","ref":"Spex.DSL.html#spex/3-example"},{"type":"macro","title":"Options - Spex.DSL.spex/3","doc":"* `:description` - Human-readable description of the specification\n  * `:tags` - List of atoms for categorizing the specification\n  * `:context` - Map of additional context information","ref":"Spex.DSL.html#spex/3-options"},{"type":"macro","title":"Spex.DSL.then_/2","doc":"Defines the expected outcome.","ref":"Spex.DSL.html#then_/2"},{"type":"macro","title":"Spex.DSL.then_/3","doc":"","ref":"Spex.DSL.html#then_/3"},{"type":"macro","title":"Spex.DSL.when_/2","doc":"Defines the action being tested.","ref":"Spex.DSL.html#when_/2"},{"type":"macro","title":"Spex.DSL.when_/3","doc":"","ref":"Spex.DSL.html#when_/3"},{"type":"module","title":"Spex.Helpers","doc":"Common helper functions for spex files.\n\nThese helpers provide reusable patterns for application startup,\nconnectivity testing, and other common spex operations.","ref":"Spex.Helpers.html"},{"type":"function","title":"Spex.Helpers.application_running?/1","doc":"Checks if an application is currently running.","ref":"Spex.Helpers.html#application_running?/1"},{"type":"function","title":"Spex.Helpers.can_connect_to_scenic_mcp?/1","doc":"Checks if we can connect to a Scenic MCP server on the given port.","ref":"Spex.Helpers.html#can_connect_to_scenic_mcp?/1"},{"type":"function","title":"Spex.Helpers.start_scenic_app/2","doc":"Starts a Scenic application with MCP server and waits for it to be ready.\n\nThis helper handles the common pattern of:\n1. Ensuring compilation (needed for mix spex)\n2. Starting the application\n3. Waiting for MCP server\n4. Setting up cleanup","ref":"Spex.Helpers.html#start_scenic_app/2"},{"type":"function","title":"Parameters - Spex.Helpers.start_scenic_app/2","doc":"- `app_name` - The application atom (e.g., `:quillex`)\n- `opts` - Optional configuration\n  - `:port` - MCP server port (default: 9999)\n  - `:timeout_retries` - Connection timeout retries (default: 20)","ref":"Spex.Helpers.html#start_scenic_app/2-parameters"},{"type":"function","title":"Returns - Spex.Helpers.start_scenic_app/2","doc":"- `{:ok, context}` with app_name and port on success\n- Raises on failure","ref":"Spex.Helpers.html#start_scenic_app/2-returns"},{"type":"function","title":"Example - Spex.Helpers.start_scenic_app/2","doc":"setup_all do\n      start_scenic_app(:quillex)\n    end","ref":"Spex.Helpers.html#start_scenic_app/2-example"},{"type":"function","title":"Spex.Helpers.wait_for_mcp_server/2","doc":"Waits for MCP server to be ready with configurable retries.","ref":"Spex.Helpers.html#wait_for_mcp_server/2"},{"type":"module","title":"Spex.Reporter","doc":"Handles reporting and output formatting for spex execution.\n\nProvides a clean interface for tracking spex execution progress and\ngenerating human-readable output.","ref":"Spex.Reporter.html"},{"type":"function","title":"Spex.Reporter.scenario_failed/2","doc":"Reports failure of a scenario.","ref":"Spex.Reporter.html#scenario_failed/2"},{"type":"function","title":"Spex.Reporter.scenario_passed/1","doc":"Reports successful completion of a scenario.","ref":"Spex.Reporter.html#scenario_passed/1"},{"type":"function","title":"Spex.Reporter.spex_failed/2","doc":"Reports failure of a specification.","ref":"Spex.Reporter.html#spex_failed/2"},{"type":"function","title":"Spex.Reporter.spex_passed/1","doc":"Reports successful completion of a specification.","ref":"Spex.Reporter.html#spex_passed/1"},{"type":"function","title":"Spex.Reporter.start_scenario/1","doc":"Starts reporting for a new scenario.","ref":"Spex.Reporter.html#start_scenario/1"},{"type":"function","title":"Spex.Reporter.start_spex/2","doc":"Starts reporting for a new specification.","ref":"Spex.Reporter.html#start_spex/2"},{"type":"function","title":"Spex.Reporter.step/2","doc":"Reports execution of a Given-When-Then step.","ref":"Spex.Reporter.html#step/2"},{"type":"module","title":"Spex.StepExecutor","doc":"Core step execution system for Spex.\n\nHandles stepping, manual mode, timing, and execution control across all adapters.\nThis module provides framework-agnostic step control, allowing manual mode to work\nwith any testing scenario (Scenic, Phoenix, libraries, etc.).","ref":"Spex.StepExecutor.html"},{"type":"function","title":"Spex.StepExecutor.execute_step/3","doc":"Executes a step with the configured execution mode.\n\nSupports:\n- Normal execution (immediate)\n- Timed execution (with delays)\n- Manual mode (step-by-step with user prompts)","ref":"Spex.StepExecutor.html#execute_step/3"},{"type":"function","title":"Parameters - Spex.StepExecutor.execute_step/3","doc":"* `step_type` - The type of step (\"Given\", \"When\", \"Then\", \"And\")\n  * `description` - Human-readable description of the step\n  * `step_function` - The function to execute for this step","ref":"Spex.StepExecutor.html#execute_step/3-parameters"},{"type":"function","title":"Configuration - Spex.StepExecutor.execute_step/3","doc":"Reads configuration from application environment:\n- `:spex, :manual_mode` - Boolean, enables manual stepping\n- `:spex, :step_delay` - Integer, delay in ms between steps\n- `:spex, :speed` - Atom, execution speed (:slow, :normal, :fast, :manual)","ref":"Spex.StepExecutor.html#execute_step/3-configuration"},{"type":"task","title":"mix spex","doc":"Run spex files - executable specifications for AI-driven development.\n\nSpex provides a framework for writing executable specifications that serve as\nboth tests and living documentation, optimized for AI-driven development workflows.\n\nEach spex file manages its own application lifecycle using setup_all and setup blocks:\n- setup_all: Application startup and shutdown\n- setup: State reset between tests\n- Context passing between test steps\n- Integration with external tools (like ScenicMCP for GUI testing)","ref":"Mix.Tasks.Spex.html"},{"type":"task","title":"Usage - mix spex","doc":"mix spex                    # Run all spex files\n    mix spex path/to/file.exs   # Run specific spex file\n    mix spex --help             # Show this help","ref":"Mix.Tasks.Spex.html#module-usage"},{"type":"task","title":"Options - mix spex","doc":"--pattern       File pattern to match (default: test/spex/**/*_spex.exs)\n    --verbose       Show detailed output\n    --timeout       Test timeout in milliseconds (default: 60000)\n    --manual        Interactive manual mode - step through each action","ref":"Mix.Tasks.Spex.html#module-options"},{"type":"task","title":"Examples - mix spex","doc":"mix spex\n    mix spex test/spex/user_login_spex.exs\n    mix spex --pattern \"**/integration_*_spex.exs\"\n    mix spex --only-spex --verbose\n    mix spex --manual           # Interactive step-by-step mode","ref":"Mix.Tasks.Spex.html#module-examples"},{"type":"task","title":"Configuration - mix spex","doc":"You can configure spex behavior in your config files:\n\n    config :spex,\n      manual_mode: false,\n      step_delay: 0\n\nApplication lifecycle is handled in individual spex files using setup_all blocks.","ref":"Mix.Tasks.Spex.html#module-configuration"},{"type":"function","title":"Mix.Tasks.Spex.run/1","doc":"Callback implementation for  Mix.Task.run/1 .","ref":"Mix.Tasks.Spex.html#run/1"},{"type":"extras","title":"Spex","doc":"# Spex\n\n[![Hex.pm](https://img.shields.io/hexpm/v/spex.svg)](https://hex.pm/packages/spex)\n[![Documentation](https://img.shields.io/badge/docs-hexpm-blue.svg)](https://hexdocs.pm/spex)\n\n**Executable Specifications for AI-Driven Development**\n\nSpex is a framework for writing executable specifications that serve as both tests and living documentation, optimized for AI-driven development workflows.","ref":"readme.html"},{"type":"extras","title":"Features - Spex","doc":"- **Clean DSL**: Intuitive Given-When-Then syntax for readable specifications\n- **ExUnit Foundation**: Built on ExUnit with additional AI-optimized features\n- **Scenic Integration**: Built-in helpers for GUI testing with Scenic applications\n- **AI-Optimized**: Manual mode, semantic helpers, and step-by-step execution\n- **Mix Integration**: Run with `mix spex` command only","ref":"readme.html#features"},{"type":"extras","title":"Installation - Spex","doc":"Add `spex` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:spex, \"~> 0.1.0\"}\n  ]\nend\n```","ref":"readme.html#installation"},{"type":"extras","title":"Quick Start - Spex","doc":"","ref":"readme.html#quick-start"},{"type":"extras","title":"1. Write Your First Spex - Spex","doc":"Create a file `test/spex/user_registration_spex.exs`:\n\n```elixir\ndefmodule MyApp.UserRegistrationSpex do\n  use Spex\n\n  setup_all do\n    # Start your application or setup shared state\n    {:ok, %{base_url: \"http://localhost:4000\"}}\n  end\n\n  spex \"user can register successfully\",\n    description: \"Validates the user registration flow\",\n    tags: [:user_management, :registration] do\n    \n    scenario \"with valid data\", context do\n      given_ \"valid user registration data\", context do\n        user_data = %{\n          email: \"test@example.com\",\n          password: \"secure_password123\",\n          name: \"Test User\"\n        }\n        assert valid_registration_data?(user_data)\n        Map.put(context, :user_data, user_data)\n      end\n\n      when_ \"user submits registration\", context do\n        {:ok, user} = MyApp.Users.register(context.user_data)\n        assert user.email == context.user_data.email\n        Map.put(context, :user, user)\n      end\n\n      then_ \"user account is created and can login\", context do\n        assert {:ok, _session} = MyApp.Auth.login(\n          context.user_data.email, \n          context.user_data.password\n        )\n      end\n    end\n  end\nend\n```","ref":"readme.html#1-write-your-first-spex"},{"type":"extras","title":"2. Run Your Spex - Spex","doc":"```bash\n# Run all spex files\nmix spex\n\n# Run specific spex file\nmix spex test/spex/user_registration_spex.exs\n\n# Run with verbose output\nmix spex --verbose\n\n# Run in manual mode (step-by-step)\nmix spex --manual\n```\n\n**Important**: Spex files can ONLY be run with `mix spex`, not `mix test`. This ensures proper compilation and application lifecycle management.","ref":"readme.html#2-run-your-spex"},{"type":"extras","title":"3. See Beautiful Output - Spex","doc":"```\n🎯 Running Spex: user can register successfully\n==================================================\n   Validates the user registration flow\n   Tags: #user_management #registration\n\n  📋 Scenario: with valid data\n    Given: valid user registration data\n    When: user submits registration\n    Then: user account is created and can login\n  ✅ Scenario passed: with valid data\n\n✅ Spex completed: user can register successfully\n```","ref":"readme.html#3-see-beautiful-output"},{"type":"extras","title":"GUI Testing with Scenic - Spex","doc":"For Scenic applications, use the built-in helpers:\n\n```elixir\ndefmodule MyGUI.LoginSpex do\n  use Spex\n\n  setup_all do\n    # Start Scenic application with MCP server\n    Spex.Helpers.start_scenic_app(:my_gui_app)\n  end\n\n  spex \"user can login via GUI\", context do\n    scenario \"successful login flow\", context do\n      given_ \"the application is running\", context do\n        assert Spex.Helpers.application_running?(:my_gui_app)\n        assert Spex.Helpers.can_connect_to_scenic_mcp?(context.port)\n      end\n\n      when_ \"user enters valid credentials\", context do\n        # Use scenic_mcp tools for interaction\n        ScenicMcp.send_keys(text: \"user@example.com\")\n        ScenicMcp.send_keys(key: \"tab\")\n        ScenicMcp.send_keys(text: \"password123\")\n        ScenicMcp.send_keys(key: \"enter\")\n      end\n\n      then_ \"user is logged in successfully\", context do\n        # Take screenshot for verification\n        ScenicMcp.take_screenshot(filename: \"logged_in_dashboard\")\n        viewport_state = ScenicMcp.Probes.viewport_state()\n        assert viewport_state.name == :main_viewport\n      end\n    end\n  end\nend\n```","ref":"readme.html#gui-testing-with-scenic"},{"type":"extras","title":"Framework Helpers - Spex","doc":"Spex provides semantic helpers for common patterns:\n\n```elixir\n# Start Scenic applications with MCP server\nSpex.Helpers.start_scenic_app(:quillex)\nSpex.Helpers.start_scenic_app(:flamelex, port: 8888)\n\n# Test connectivity\nSpex.Helpers.can_connect_to_scenic_mcp?(9999)\nSpex.Helpers.application_running?(:my_app)\n\n# Automatically handles:\n# - Compilation (Mix.Task.run(\"compile\"))\n# - Application startup and cleanup\n# - MCP server waiting and connection testing\n```","ref":"readme.html#framework-helpers"},{"type":"extras","title":"Manual Mode - Interactive Testing - Spex","doc":"Run spex in manual mode for step-by-step execution:\n\n```bash\nmix spex --manual\n```\n\n**Manual mode gives you:**\n- 🎯 Pause between each Given/When/Then/And step\n- 🐚 Drop into IEx shell for debugging (`iex` command)\n- 📸 Take screenshots and inspect state\n- ❌ Quit anytime (`q` command)\n\nPerfect for:\n- Debugging failing tests step-by-step\n- Understanding how your app responds to actions\n- Creating visual documentation of workflows\n- Training and demonstration purposes","ref":"readme.html#manual-mode-interactive-testing"},{"type":"extras","title":"Architecture - Spex","doc":"","ref":"readme.html#architecture"},{"type":"extras","title":"Built on ExUnit - Spex","doc":"Spex is 100% built on ExUnit but provides a controlled execution environment:\n\n```elixir\n# When you write:\nuse Spex\n\n# You get:\nuse ExUnit.Case, async: false  # Standard ExUnit test case\nimport Spex.DSL               # spex/scenario/given_/when_/then_\n```","ref":"readme.html#built-on-exunit"},{"type":"extras","title":"Execution Flow - Spex","doc":"```\nmix spex → Mix.Tasks.Spex → ExUnit.start() → Load spex files → ExUnit.run()\n```","ref":"readme.html#execution-flow"},{"type":"extras","title":"Core Modules - Spex","doc":"- **`Spex`** - Main module with `use` macro and helpers\n- **`Spex.DSL`** - Given-When-Then macros\n- **`Spex.Helpers`** - Semantic helper functions\n- **`Spex.StepExecutor`** - Manual mode and execution control\n- **`Mix.Tasks.Spex`** - Mix task with lifecycle management","ref":"readme.html#core-modules"},{"type":"extras","title":"Philosophy - Spex","doc":"Spex bridges the gap between human requirements and AI validation by providing:\n\n- **Executable Documentation**: Specifications that run as tests\n- **AI-Readable Format**: Structured, semantic test descriptions\n- **Visual Evidence**: Screenshot capture and state validation  \n- **Interactive Control**: Manual mode for human oversight\n- **Semantic Helpers**: Functions that read like human language\n\nThis enables AI systems to write, execute, and understand tests while maintaining human readability and control.","ref":"readme.html#philosophy"},{"type":"extras","title":"📚 Documentation - Spex","doc":"- **[Getting Started Guide](docs/GETTING_STARTED.md)** - New to Spex? Start here\n- **[How-To Guide](docs/HOW_TO_GUIDE.md)** - Problem-solving for specific tasks\n- **[Technical Reference](docs/TECHNICAL_REFERENCE.md)** - Complete API documentation\n- **[Troubleshooting](docs/TROUBLESHOOTING.md)** - Solutions for common problems","ref":"readme.html#documentation"},{"type":"extras","title":"Contributing - Spex","doc":"We welcome contributions! Please see the documentation in `/docs` for details.","ref":"readme.html#contributing"},{"type":"extras","title":"License - Spex","doc":"This project is licensed under the MIT License.","ref":"readme.html#license"},{"type":"extras","title":"Inspiration - Spex","doc":"Spex is inspired by:\n- Behavior-Driven Development (BDD)\n- Specification by Example\n- AI-driven development workflows\n- The Elixir/OTP philosophy of observable, testable systems\n\nPerfect for teams building the future of AI-assisted software development.","ref":"readme.html#inspiration"},{"type":"extras","title":"Changelog","doc":"# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.1.0] - 2024-07-06","ref":"changelog.html"},{"type":"extras","title":"Added - Changelog","doc":"- Initial release of Spex framework\n- Given-When-Then DSL for executable specifications\n- Built on ExUnit with AI-optimized features\n- `Spex.Helpers` module with semantic helper functions\n- `mix spex` command for running specifications\n- Manual mode with interactive step-by-step execution\n- Built-in support for Scenic GUI testing\n- Context flow between test steps\n- Framework setup helpers for application lifecycle management\n- Comprehensive documentation and examples","ref":"changelog.html#added"},{"type":"extras","title":"Features - Changelog","doc":"- **Core DSL**: `spex`, `scenario`, `given_`, `when_`, `then_`, `and_` macros\n- **Semantic Helpers**: `start_scenic_app/2`, `can_connect_to_scenic_mcp?/1`, `application_running?/1`\n- **Manual Mode**: Interactive testing with IEx shell integration\n- **Mix Integration**: Dedicated `mix spex` command with proper lifecycle management\n- **GUI Testing**: Built-in helpers for Scenic applications with MCP server integration\n- **Documentation**: Comprehensive guides in `/docs` directory","ref":"changelog.html#features"},{"type":"extras","title":"Architecture - Changelog","doc":"- Built on ExUnit for reliability and compatibility\n- Controlled execution environment via `mix spex` only\n- Automatic compilation and application lifecycle management\n- Clean separation between framework and user code","ref":"changelog.html#architecture"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}